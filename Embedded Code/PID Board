// LIBRARY INCLUSIONS
#include <Arduino_LSM6DS3.h>
#include <Wire.h>
#include <Adafruit_LIS3MDL.h>
#include <Adafruit_Sensor.h>
#include <ScioSense_ENS220.h>
#include <ens220.h>
#include <utils.h>
#include <SPI.h>
#include <SD.h>
#include <SparkFun_u-blox_GNSS_v3.h>
#include <Arduino.h>
#include "i2c_interface.h"
#include "FeedBackServo.h"
#include <Adafruit_NeoPixel.h>
#include <Servo.h>
#include <RTClib.h>

// PINS AND DEFINITIONS
#define BATTERY_PIN A0           // Analog pin for voltage divider circuit
#define RPM_PIN A4               // Pin for Hall effect sensor
#define SD_CS_PIN 6              // Chip select pin for SD card
#define RELEASE_PIN 12           // Release servo pin
#define SERVO_PIN 13             // Servo pin for GND camera stabilization
//#define FEEDBACK_PIN 9           // Feedback signal pin for servo control
#define I2C_ADDRESS 0x20         // I2C Address for ENS 220
#define DS1307_I2C_ADDRESS 0x68  // I2C Address for DS1307
//#define SERIAL_BAUDRATE 57600    // Speed of Serial Communication with the computer (ENS220)
//#define INTN_1 4                 // Interrupt pin for ENS220
#define CAMERA1_PIN 10           // Blade camera
#define CAMERA2_PIN 11           // Ground camera
#define LED_DATA 5
#define NUM_LEDS 5             // Number of LEDs for FastLED
//#define MAG1_I2C_ADDRESS 0x1C  // First LIS3MDL address
//#define MAG2_I2C_ADDRESS 0x1E  // Second LIS3MDL address
//#define IMU1_I2C_ADDRESS 0x6A  // First LSM6DS3 address
//#define IMU2_I2C_ADDRESS 0x6B  // Second LSM6DS3 address
#define TEAM_ID "3195"

// STATE MANAGEMENT VARIABLES
enum FlightState {
  LAUNCH_PAD,
  ASCENT,
  APOGEE,
  DESCENT,
  LANDED
};

// Objects
FlightState flightState = LAUNCH_PAD;  // Initial state
ScioSense::ENS220 ens220;
I2cInterface i2c_1;            // Added for ENS220 single-shot mode
Adafruit_LIS3MDL lis3mdl;      // Magnetometer
//Adafruit_LIS3MDL lis3mdl_FC;   // First magnetometer
//Adafruit_LIS3MDL lis3mdl_CAM;  // Second magnetometer
Servo servo;
Servo camServo;
File dataFile;
File backupFile;
RTC_DS1307 rtc;      // DS1307

// Variables
unsigned long landedTime = 0;
unsigned long lastOrientationTime = 0;
//float lastOrientationX = 0.0, lastOrientationY = 0.0, lastOrientationZ = 0.0;
uint8_t satellites = 0;
float voltageDividerFactor = 0.012089;                    // Adjust based on resistor values in voltage divider
float lastTransmissionTime = 0;                           // Last time of telemetry transmission
char currentTime[9] = "00:00:00";                         // Mission time in "HH:MM:SS"
char gpsTime[9] = "00:00:00";                             // GPS time in "HH:MM:SS"
float mag2X, mag2Y, mag2Z;                                // Magnetometer data for second sensor
float accel2X, accel2Y, accel2Z, gyro2X, gyro2Y, gyro2Z;  // IMU data for second sensor (if separate IMU object is used)
char lastCommand[32];                                     // Last received command
unsigned int packetCount = 0;
bool telemetryEnabled = true;  // Telemetry Control

// Camera stabilization variables
float cameraposition = 0;
unsigned long lastRpmTime = 0;        // last time of an magnet detection
volatile unsigned long rpmCount = 0;  // RPM counter
float currentInterruptTime = 0;       // Current time of an interrupt
float timeDifference = 0;             // Time difference between two consecutive interrupts
float lastInterruptTime = 0;

// Altitude calculation variables
float apogeeAltitude = 0.0;
float maxAltitude = 0;
bool releaseActivated = false;
bool simulationMode = false;
float simulatedPressure = 0.0;
float receivedPressure = 0.0;       // For SIM_ACTIVATE pressure input
float referencePressure = 1013.25;  // Default reference point (sea level)
const int historySize = 10;
float pressure;
float temperature;
float altitudeHistory[historySize];           // Store altitude
float velocityHistory[historySize];           // Store velocity
unsigned long timestampHistory[historySize];  // Store time
float latestVelocity;

// Variables used for PID
float setpoint = 1000.0;           // Desired setpoint placeholder
float input = 0.0;                 // Current system input
float output = 0.0;                // PID output
float error = 0.0;                 // Current error
float lastError = 0.0;             // Previous error
float integral = 0.0;              // tracks cumulative error
const float K_proportional = 1.0;  // Proportional gain
const float K_integral = 0.1;      // Integral gain
const float K_derivative = 0.01;   // Derivative gain
float heading;

///////////////////////// FUNCTIONS /////////////////////////

// Function to calculate altitude from pressure
float calculateAltitude(float pressure) {
  // Constants for the barometric formula
  const float temperatureLapseRate = 0.0065;  // Temperature lapse rate in K/m
  const float seaLevelTemperature = 288.15;   // Sea level standard temperature in K
  const float gasConstant = 8.3144598;        // Universal gas constant in J/(mol*K)
  const float molarMass = 0.0289644;          // Molar mass of Earth's air in kg/mol
  const float gravity = 9.80665;              // Acceleration due to gravity in m/s^2

  // Calculate altitude using the barometric formula
  float altitude = (seaLevelTemperature / temperatureLapseRate) * (1 - pow((pressure / referencePressure), (gasConstant * temperatureLapseRate) / (gravity * molarMass)));
  return altitude;
}

// Function to update the altitude history array
void updateAltitudeHistory(float altitudeHistory[], unsigned long timestampHistory[], float newAltitude, int size) {
  // Shift all elements in altitudeHistory and timestampHistory to the right
  for (int i = size - 1; i > 0; i--) {
    altitudeHistory[i] = altitudeHistory[i - 1];
    timestampHistory[i] = timestampHistory[i - 1];
  }

  // Update the first element with the new altitude and current timestamp
  altitudeHistory[0] = newAltitude;
  timestampHistory[0] = millis();
}

// Function to calculate velocity and update the velocity history array
void updateVelocityHistory(float altitudeHistory[], float velocityHistory[], unsigned long timestampHistory[], int size) {
  // Calculate the time difference between the two most recent updates in milliseconds
  unsigned long timeDifferenceMillis = timestampHistory[0] - timestampHistory[1];
  float timeDifferenceSeconds = timeDifferenceMillis / 1000.0;  // Convert to seconds

  // Calculate the latest velocity
  latestVelocity = (altitudeHistory[0] - altitudeHistory[1]) / timeDifferenceSeconds;

  // Shift all elements in velocityHistory to the right
  for (int i = size - 1; i > 0; i--) {
    velocityHistory[i] = velocityHistory[i - 1];
  }

  // Update the first element with the latest velocity
  velocityHistory[0] = latestVelocity;
}

float avg(float arr[], int size) {
  float sum = 0.0;
  for (int i = 0; i < size; i++) {
    sum += arr[i];
  }
  return sum / size;
}

// Function for PID Camera Stabilization
void pidControl(float input, float setpoint, float &lastError, float &integral, Servo &camServo) {
  // PID tuning parameters
  const float K_proportional = 1.0;  // Proportional gain
  const float K_integral = 0.1;      // Integral gain
  const float K_derivative = 0.01;   // Derivative gain

  // Calculate the error
  float error = setpoint - input;  // Calculate the error based on difference between setpoint and input
  if (error > 180) {
    error = error - 360;  // account for the closest path to the setpoint being across the 0° line
  } else if (error < -180) {
    error = error + 360;  // account for the closest path to the setpoint being across the 0° line the other way
  }

  // Calculate the integral term
  integral += error;

  // Calculate the derivative term
  float derivative = error - lastError;

  // Calculate the PID output
  float output = K_proportional * error + K_integral * integral + K_derivative * derivative;

  // Store the current error as the last error to prepare for the next iteration
  lastError = error;

  // Map heading to servo angle (assuming servo range is 0-180°)
  int currentAngle = camServo.read();                 // Read current servo position
  int targetAngle = map(input, 0, 360, 0, 180);    // Adjust based on servo range
  int adjustedAngle = currentAngle - (int)output;  // Adjusting servo based on the PID output

  // Constrain to servo range (0-180°)
  if (adjustedAngle < 0) adjustedAngle = 0;
  if (adjustedAngle > 180) adjustedAngle = 180;

  // Convert target angle to microseconds (1000 to 2000 range)
  int targetMicroseconds = map(targetAngle, 0, 180, 1000, 2000);
  camServo.writeMicroseconds(targetMicroseconds);  // Set servo to target microseconds

  // Read feedback and correct (optional, depends on FeedBackServo implementation)
  if (abs(currentAngle - targetAngle) > 5) {  // Tolerance of 5 degrees
    camServo.writeMicroseconds(targetMicroseconds);  // Reapply correction
  }

  // Debug output
  Serial.print("Heading: ");
  Serial.print(input);
  Serial.print("°  Target Servo Angle: ");
  Serial.print(targetAngle);
  Serial.print("°  Current Servo Angle: ");
  Serial.println(currentAngle);
}

void rpmISR() {
  currentInterruptTime = millis();                            // Get the current time
  timeDifference = currentInterruptTime - lastInterruptTime;  // Calculate the time difference between interrupts
  lastInterruptTime = currentInterruptTime;
}

// ENS220 Sensor Initialization
void SingleShotMeasure_setup() {
  // Start the communication, confirm the device PART_ID, and read the device UID
  i2c_1.begin(Wire, I2C_ADDRESS);

  while (ens220.begin(&i2c_1) != true) {
    Serial.println("Waiting for I2C to start");
    delay(1000);
  }

  Serial.print("Device UID: ");
  Serial.println(ens220.getUID(), HEX);

  // Choose the desired configuration of the sensor. In this example we will use the Lowest Noise settings from the datasheet
  ens220.setDefaultConfiguration();
  ens220.setPressureConversionTime(ENS220::PressureConversionTime::T_16_4);
  ens220.setOversamplingOfPressure(ENS220::Oversampling::N_128);
  ens220.setOversamplingOfTemperature(ENS220::Oversampling::N_128);
  ens220.setPressureTemperatureRatio(ENS220::PressureTemperatureRatio::PT_1);
  ens220.setStandbyTime(ENS220::StandbyTime::OneShotOperation);
  ens220.setPressureDataPath(ENS220::PressureDataPath::Direct);

  // Write the desired configuration into the sensor
  ens220.writeConfiguration();
}

void SingleShotMeasure_loop()
{
    // Start single shot measurement
    ens220.singleShotMeasure(ENS220::Sensor::TemperatureAndPressure);
    
    // Wait until the measurement is ready
    ens220.waitSingleShot();
    
    // Check the DATA_STAT from the sensor. If data is available, it reads it
    auto result = ens220.update();   
     
    if(result == ENS220::Result::Ok)
    {
      if(hasFlag(ens220.getDataStatus(), ENS220::DataStatus::PressureReady) && hasFlag(ens220.getDataStatus(), ENS220::DataStatus::TemperatureReady))
      {
          // Send the values that were collected during the ens220.update()
          Serial.print("P[hPa]:");
          Serial.print(ens220.getPressureHectoPascal());
          pressure = ens220.getPressureHectoPascal();
          Serial.print("\tT[C]:");
          Serial.println(ens220.getTempCelsius());
          temperature = ens220.getTempCelsius();
      }
    }
}

// Updated updateTime function to use DS1307 RTC
void updateTime(char *currentTime, size_t size) {
  Serial.println("Time update must still be created!");
}

void updateFlightState(float altitude, float velocity, float x, float y, float z) {
  switch (flightState) {
    case LAUNCH_PAD:
      if (altitude > 5 && velocity > 8) {
        flightState = ASCENT;
        Serial.println("Flight state: ASCENT");
      }
      break;
    case ASCENT:
      if (velocity <= -1) {
        flightState = APOGEE;
        apogeeAltitude = altitude;
        Serial.println("Flight state: APOGEE");
      }
      break;
    case APOGEE:
      if (velocity < 0) {
        flightState = DESCENT;
        Serial.println("Flight state: DESCENT");
      }
      break;
    case DESCENT:
      if (velocity == 0 && millis() - lastOrientationTime > 10000) {
        flightState = LANDED;
        landedTime = millis();
        Serial.println("Flight state: LANDED");
      }
      break;
    case LANDED:
      {
      }
      break;
  }
  // Update last orientation values
  lastOrientationTime = millis();
  lastOrientationX = x;
  lastOrientationY = y;
  lastOrientationZ = z;
}

void setup() {

  Serial.begin(2000000);  // Debugging output
  Wire.begin();
  Wire.setClock(400000);
  
  // Initialize release servo
  servo.attach(RELEASE_PIN);
  // Initialize camera servo
  camServo.attach(SERVO_PIN);

  // Initialize DS1307 RTC
  if (!rtc.begin()) {
    Serial.println("Couldn't find DS1307 RTC!");
  }
  
  if (!rtc.isrunning()) {
    Serial.println("RTC is NOT running, setting time to compile time.");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));  // Set to compile time
  }

  // Initialize cameras control pins (e.g., for power on/off)
  pinMode(CAMERA1_PIN, OUTPUT);    // Set camera control pin to output
  digitalWrite(CAMERA1_PIN, LOW);  // Make sure camera is OFF initially
  pinMode(CAMERA2_PIN, OUTPUT);
  digitalWrite(CAMERA2_PIN, LOW);

  // Initialize SD card
  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD card initialization failed!");
  } else {
    Serial.println("SD card initialized successfully");
  }
  backupFile = SD.open("backup.txt", FILE_WRITE);

  // Initialize RPM sensor
  pinMode(RPM_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(RPM_PIN), rpmISR, RISING);

  if (!gps.begin()) {
    Serial.println("GNSS v3 initialization failed!");
  }
  gps.setNavigationRate(5); // Set rate of gps (Hz)

  if (!lis3mdl_FC.begin_I2C(MAG1_I2C_ADDRESS)) {
    Serial.println("Failed to find LIS3MDL #1");
  } else {
    Serial.println("LIS3MDL #1 Found!");
    lis3mdl_FC.setPerformanceMode(LIS3MDL_MEDIUMMODE);
    lis3mdl_FC.setOperationMode(LIS3MDL_CONTINUOUSMODE);
    lis3mdl_FC.setDataRate(LIS3MDL_DATARATE_155_HZ);
    lis3mdl_FC.setRange(LIS3MDL_RANGE_4_GAUSS);
  }

  // Initialize first IMU (LSM6DS3)
  if (!IMU.begin()) {
    Serial.println("Error initializing LSM6DS3 #1!");
  } else {
    Serial.print("Accelerometer #1 sample rate = ");
    Serial.print(IMU.accelerationSampleRate());
    Serial.println(" Hz");
    Serial.println("Acceleration in g's");
    Serial.println("X\tY\tZ");
  }

  // Initialize LIS3MDL (Magnetometer)
  if (!lis3mdl.begin_I2C()) {  // hardware I2C mode
    Serial.println("Failed to find LIS3MDL chip");
  } else {
    Serial.println("LIS3MDL Found!");
    lis3mdl.setPerformanceMode(LIS3MDL_MEDIUMMODE);
    lis3mdl.setOperationMode(LIS3MDL_CONTINUOUSMODE);
    lis3mdl.setDataRate(LIS3MDL_DATARATE_155_HZ);
    lis3mdl.setRange(LIS3MDL_RANGE_4_GAUSS);
  }

  SingleShotMeasure_setup();
}

void loop() {

  updateTime(currentTime, sizeof(currentTime));
  // Read data from XBee or Serial1
  char command[64] = {0};

  unsigned long missionTime = millis() / 1000;  // Mission time in seconds

  // Calculate instantaneous RPM
  float rpm = (timeDifference > 0) ? (60000 / timeDifference) : 0;  // Calculate RPM
  lastRpmTime = millis();                                           // Immediately update last RPM time for min error
  rpmCount = 0;

  // Read battery voltage
  float currentVoltage = analogRead(BATTERY_PIN) * voltageDividerFactor;
  
  // Read magnetometer data
  sensors_event_t magEvent1;
  lis3mdl.getEvent(&magEvent1);
  // Read second magnetometer
  sensors_event_t magEvent2;
  lis3mdl_CAM.getEvent(&magEvent2);
  mag2X = magEvent2.magnetic.x;
  mag2Y = magEvent2.magnetic.y;
  mag2Z = magEvent2.magnetic.z;
  // Read accelerometer and gyroscope data
  float accelX, accelY, accelZ;
  float gyroX, gyroY, gyroZ;
  if (IMU.accelerationAvailable()) {
    IMU.readAcceleration(accelX, accelY, accelZ);
    Serial.print(accelX);
    Serial.print('\t');
    Serial.print(accelY);
    Serial.print('\t');
    Serial.println(accelZ);
  }
  if (IMU.gyroscopeAvailable()) {
    IMU.readGyroscope(gyroX, gyroY, gyroZ);
  }
  
  // Retrieve Temperature and Pressure from ENS220 (Single Shot Mode)
  SingleShotMeasure_loop();

  // Calculate altitude from pressure
  float altitude = calculateAltitude(pressure);
  
  // Update maxAltitude during ascent
  if (flightState == ASCENT && altitude > maxAltitude) {
    maxAltitude = altitude;
  }

    switch (flightState) {
      case LAUNCH_PAD: state = "LAUNCH_PAD"; break;
      case ASCENT: state = "ASCENT"; break;
      case APOGEE: state = "APOGEE"; break;
      case DESCENT: state = "DESCENT"; break;
      case LANDED: state = "LANDED"; break;
      default: state = "UNKNOWN"; break;
    }
    
    snprintf(telemetry, sizeof(telemetry),
              "%s,%s,%u,%s,%s,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%u,%s,%.1f,%.4f,%.4f,%u,%s,COSMOS",
              TEAM_ID, currentTime, packetCount, mode, state,
              altitude, temperature, pressure, currentVoltage,
              gyroX, gyroY, gyroZ, accelX, accelY, accelZ,
              magEvent1.magnetic.x, magEvent1.magnetic.y, 
              magEvent1.magnetic.z, rpm, gpsTime, gpsAltitude,
              latitude, longitude, satellites, lastCommand);
    
    Serial.println(telemetry);
    // Save telemetry to SD card
    dataFile = SD.open("data.txt", FILE_WRITE);
    if (dataFile) {
      dataFile.println(telemetry);
      dataFile.close();
      Serial.println("Finished writing to SD card!");
    } else {
      Serial.println("Error writing to SD card!");
    }
    packetCount++;  // Increment packet count

  // Calculate heading
  heading = atan2(magEvent2.magnetic.y, magEvent2.magnetic.x);
  heading = heading * 180 / PI;     // Convert to degrees
  if (heading < 0) heading += 360;  // Ensure 0-360 range

  // Used for some state transitions
  updateAltitudeHistory(altitudeHistory, timestampHistory, altitude, historySize);
  updateVelocityHistory(altitudeHistory, velocityHistory, timestampHistory, historySize);

  Serial.println("Velocity: ");
  Serial.print(latestVelocity);

  switch (flightState) {
    case LAUNCH_PAD:
      // Code for launch state
      updateFlightState(altitude, velocityHistory[0], accelX, accelY, accelZ);
      break;
    case ASCENT:
      // Code for ascent state
      updateFlightState(altitude, velocityHistory[0], accelX, accelY, accelZ);
      break;
    case APOGEE:
      // Code for Apogee state
      updateFlightState(altitude, velocityHistory[0], accelX, accelY, accelZ);
      break;
    case DESCENT:
      // Code for separated state
      updateFlightState(altitude, velocityHistory[0], accelX, accelY, accelZ);
      // PID Camera Stabilization
      pidControl(heading, setpoint, lastError, integral, servo);
      break;
    case LANDED:
      updateFlightState(altitude, velocityHistory[0], accelX, accelY, accelZ);
      if (avg(velocityHistory, historySize) < 1) {
        flightState = LANDED;
      }
      break;
  }
}
